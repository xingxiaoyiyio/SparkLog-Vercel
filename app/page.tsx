
'use client';

import React, { useState, useRef, useEffect } from 'react';
import { InputArea } from '../components/InputArea';
import { ChatMessage } from '../components/ChatMessage';
import { DailySummary } from '../components/DailySummary';
import { HistoryView } from '../components/HistoryView';
import { geminiService } from '../services/geminiService';
import { Message, Role, ChatStatus, DailySummaryData } from '../types';
import { Sparkles, ScrollText, History as HistoryIcon, Eraser } from 'lucide-react';

const INITIAL_MESSAGE: Message = {
  id: 'init-1',
  role: Role.MODEL,
  text: "å˜¿ï¼ğŸ‘‹ ä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Ÿéšæ—¶è·Ÿæˆ‘è®°ä¸ªæµæ°´è´¦ï¼Œæˆ–è€…å•çº¯åæ§½ä¸€ä¸‹ã€‚æˆ‘å‡†å¤‡å¥½å•¦ï¼",
  timestamp: new Date()
};

interface HistoryItem {
    id: number;
    data: DailySummaryData;
}

export default function Home() {
  const [messages, setMessages] = useState<Message[]>([INITIAL_MESSAGE]);
  const [isInitialized, setIsInitialized] = useState(false);

  // Initialize from LocalStorage (Hydration safe)
  useEffect(() => {
    try {
      const saved = localStorage.getItem('sparklog_current_chat');
      if (saved) {
        const parsed = JSON.parse(saved);
        setMessages(parsed.map((m: any) => ({
          ...m,
          timestamp: new Date(m.timestamp)
        })));
      }
    } catch (e) {
      console.error("Failed to load chat persistence", e);
    }
    setIsInitialized(true);
  }, []);

  const [status, setStatus] = useState<ChatStatus>('idle');
  const [showSummary, setShowSummary] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [summaryData, setSummaryData] = useState<DailySummaryData | null>(null);
  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [autoGeneratedDate, setAutoGeneratedDate] = useState<string | null>(null);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, status]);

  // Persist messages
  useEffect(() => {
    if (isInitialized) {
      localStorage.setItem('sparklog_current_chat', JSON.stringify(messages));
    }
  }, [messages, isInitialized]);

  // Load history
  useEffect(() => {
    const savedHistory = localStorage.getItem('sparklog_history');
    if (savedHistory) {
      try {
        const parsed = JSON.parse(savedHistory);
        setHistory(parsed);
      } catch (e) {
        console.error("Failed to parse history", e);
      }
    }
    if (!localStorage.getItem('sparklog_chat_date')) {
      localStorage.setItem('sparklog_chat_date', new Date().toDateString());
    }
  }, []);

  // Time-based Automation
  useEffect(() => {
    const checkTimeEvents = () => {
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      const todayStr = now.toDateString();
      const storedDate = localStorage.getItem('sparklog_chat_date');

      // New Day Logic
      if (storedDate && storedDate !== todayStr) {
        console.log("New day detected. Resetting chat...");
        let pendingTodos: string[] = [];
        const savedHistoryStr = localStorage.getItem('sparklog_history');
        if (savedHistoryStr) {
          try {
            const parsedHistory: HistoryItem[] = JSON.parse(savedHistoryStr);
            if (parsedHistory.length > 0) {
              const lastEntry = parsedHistory[parsedHistory.length - 1];
              if (lastEntry.data.actionItems && lastEntry.data.actionItems.length > 0) {
                pendingTodos = lastEntry.data.actionItems;
              }
            }
          } catch (e) { console.error(e); }
        }

        let greetingText = "åˆæ˜¯æ–°çš„ä¸€å¤©ï¼â˜€ï¸ æ˜¨å¤©è¿‡å¾—è¿˜å¥½å—ï¼Ÿ";
        if (pendingTodos.length > 0) {
          greetingText += "\n\nğŸ“‹ æ˜¨å¤©çš„å¾…åŠäº‹é¡¹åˆ«å¿˜å•¦ï¼š\n" + pendingTodos.map(t => `- ${t}`).join('\n');
          greetingText += "\n\nä»Šå¤©æœ‰ä»€ä¹ˆæ–°è®¡åˆ’å—ï¼Ÿ";
        } else {
          greetingText += " ä»Šå¤©æœ‰ä»€ä¹ˆæ–°è®¡åˆ’ï¼Œæˆ–è€…åªæ˜¯æƒ³è®°å½•ç‚¹ä»€ä¹ˆï¼Ÿ";
        }

        const newGreetingMsg: Message = {
          id: Date.now().toString(),
          role: Role.MODEL,
          text: greetingText,
          timestamp: new Date()
        };

        setMessages([newGreetingMsg]);
        localStorage.setItem('sparklog_chat_date', todayStr);
        setAutoGeneratedDate(null);
      }

      // Auto Summary (23:59)
      if (currentHour === 23 && currentMinute === 59 && autoGeneratedDate !== todayStr) {
        attemptAutoSummary(todayStr);
      }
    };

    const attemptAutoSummary = (todayStr: string) => {
      setMessages(currentMessages => {
        const startOfDay = new Date();
        startOfDay.setHours(0, 0, 0, 0);
        const userLogsToday = currentMessages.filter(m => 
          m.role === Role.USER && 
          new Date(m.timestamp) >= startOfDay
        );

        if (userLogsToday.length > 0) {
          setTimeout(() => {
            handleGenerateSummary(false, true); 
          }, 0);
          setAutoGeneratedDate(todayStr);
        }
        return currentMessages;
      });
    };

    const intervalId = setInterval(checkTimeEvents, 10000);
    checkTimeEvents();
    return () => clearInterval(intervalId);
  }, [autoGeneratedDate]);

  const saveToHistory = (data: DailySummaryData) => {
    const isDuplicate = history.some(h => h.data.date === data.date && JSON.stringify(h.data.highlight) === JSON.stringify(data.highlight));
    if (isDuplicate) return;

    const newItem: HistoryItem = { id: Date.now(), data };
    const newHistory = [...history, newItem];
    setHistory(newHistory);
    localStorage.setItem('sparklog_history', JSON.stringify(newHistory));
  };

  const handleDeleteHistory = (id: number) => {
    const newHistory = history.filter(item => item.id !== id);
    setHistory(newHistory);
    localStorage.setItem('sparklog_history', JSON.stringify(newHistory));
  };

  const handleDeleteMessage = (id: string) => {
    setMessages(prev => prev.filter(msg => msg.id !== id));
  };

  const handleClearChat = () => {
    if (window.confirm("ç¡®å®šè¦æ¸…ç©ºå½“å‰çš„èŠå¤©è®°å½•å—ï¼Ÿ(å†å²æ—¥è®°ä¸ä¼šè¢«åˆ é™¤)")) {
      setMessages([INITIAL_MESSAGE]);
      setStatus('idle');
      localStorage.setItem('sparklog_chat_date', new Date().toDateString());
    }
  };

  const handleSendMessage = async (text: string, imageBase64?: string) => {
    const userMsg: Message = {
      id: Date.now().toString(),
      role: Role.USER,
      text,
      image: imageBase64,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, userMsg]);
    setStatus('thinking');

    try {
      if (text.toLowerCase().includes("wrap up") || text.includes("æ—¥ç»“") || text.includes("ä»Šæ—¥æ€»ç»“")) {
        await handleGenerateSummary(true);
        return;
      }

      // Pass history to backend so it has context
      const historyContext = messages.concat(userMsg);
      const response = await geminiService.sendMessage(text, historyContext, imageBase64);
      
      const botMsg: Message = {
        id: (Date.now() + 1).toString(),
        role: Role.MODEL,
        text: response.text,
        timestamp: new Date(),
        groundingSources: response.sources
      };
      setMessages(prev => [...prev, botMsg]);
      setStatus('idle');

    } catch (error) {
      console.error(error);
      setStatus('idle');
    }
  };

  const handleGenerateSummary = async (isTextTrigger = false, isAutoTrigger = false) => {
    const now = new Date();
    const startOfDay = new Date(now.setHours(0, 0, 0, 0));
    const endOfDay = new Date(now.setHours(23, 59, 59, 999));

    const todayMessages = messages.filter(m => {
      const mDate = new Date(m.timestamp);
      return mDate >= startOfDay && mDate <= endOfDay;
    });

    const hasUserContent = todayMessages.some(m => m.role === Role.USER);
    
    if (!hasUserContent) {
      if (!isAutoTrigger) {
        const noRecordMsg = {
          id: Date.now().toString(),
          role: Role.MODEL,
          text: "è¿˜æ²¡æœ‰è®°å½•ä»»ä½•ç¢ç‰‡å‘¢ï¼å…ˆèŠç‚¹ä»€ä¹ˆå§ï¼Œæ¯”å¦‚å‘å¼ ç…§ç‰‡æˆ–è€…åˆ†äº«ä¸ªé“¾æ¥ï¼ŸğŸ¤”",
          timestamp: new Date()
        };
        setMessages(prev => [...prev, noRecordMsg]);
      }
      setStatus('idle');
      return;
    }

    setStatus('generating_summary');
    
    if (!isTextTrigger && !isAutoTrigger) {
      setMessages(prev => [...prev, {
        id: Date.now().toString(),
        role: Role.MODEL,
        text: "æ”¶åˆ°ï¼æ­£åœ¨æŠŠæˆ‘ä»¬ä»Šå¤©çš„ç¢ç‰‡ç»‡æˆæ—¥è®°... ğŸ§µâœ¨",
        timestamp: new Date()
      }]);
    }

    try {
      const aiData = await geminiService.generateDailySummary(todayMessages);

      const rawLogs = todayMessages
        .filter(m => m.role === Role.USER && !m.text.includes("æ—¥ç»“") && !m.text.includes("ä»Šæ—¥æ€»ç»“"))
        .map(m => m.text);

      const finalData: DailySummaryData = {
        ...aiData,
        rawLog: rawLogs
      };

      setSummaryData(finalData);
      if (!isAutoTrigger) {
        setShowSummary(true);
      }
      
      saveToHistory(finalData);
      setAutoGeneratedDate(new Date().toDateString());
      setStatus('idle');
      
      if (isAutoTrigger) {
        setMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: Role.MODEL,
          text: "âœ¨ è¿™ä¸€å¤©ç»“æŸå•¦ï¼Œæˆ‘å·²ç»è‡ªåŠ¨å¸®ä½ ç”Ÿæˆäº†ä»Šæ—¥æ—¥ç»“ï¼Œå¿«å»å†å²è®°å½•é‡Œçœ‹çœ‹å§ï¼æ™šå®‰ ğŸŒ™",
          timestamp: new Date()
        }]);
      }

    } catch (e) {
      console.error("Summary failed", e);
      setStatus('idle');
      if (!isAutoTrigger) {
        setMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: Role.MODEL,
          text: "å“å‘€ï¼Œå†™æ—¥è®°çš„æ—¶å€™è¢«ç”µçº¿ç»Šå€’äº†ã€‚èƒ½å†è¯•ä¸€æ¬¡å—ï¼ŸğŸ˜…",
          timestamp: new Date()
        }]);
      }
    }
  };

  const handleHistorySelect = (data: DailySummaryData) => {
    setSummaryData(data);
    setShowHistory(false);
    setShowSummary(true);
  };

  // Prevent flash of empty content before hydration
  if (!isInitialized) return null;

  return (
    <div className="flex flex-col h-full w-full bg-transparent relative border-x border-white/20 shadow-2xl">
      <header className="bg-white/60 backdrop-blur-xl sticky top-0 z-10 border-b border-white/40">
        <div className="max-w-2xl mx-auto w-full px-6 py-4 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="bg-gradient-aurora text-white p-2.5 rounded-xl shadow-lg shadow-aurora-purple/20">
              <Sparkles size={20} />
            </div>
            <div>
              <h1 className="font-bold text-slate-800 text-lg leading-tight tracking-tight font-sans">
                <span className="text-transparent bg-clip-text bg-gradient-to-r from-aurora-purple to-aurora-green">SparkLog</span>
              </h1>
              <p className="text-[10px] text-slate-500 font-mono uppercase tracking-wider">AI Fragment Diary</p>
            </div>
          </div>
          <div className="flex gap-2">
            <button 
              onClick={handleClearChat}
              disabled={status !== 'idle' || messages.length <= 1}
              className={`p-2.5 rounded-xl transition-all border border-transparent ${
                status !== 'idle' || messages.length <= 1 
                ? 'text-slate-300 cursor-not-allowed' 
                : 'text-slate-400 hover:text-red-500 hover:bg-white hover:border-red-100 hover:shadow-sm'
              }`}
              title="æ¸…ç©ºå½“å‰å¯¹è¯"
            >
              <Eraser size={20} />
            </button>
            <div className="w-px h-8 bg-slate-200 mx-1 self-center"></div>
            <button 
              onClick={() => handleGenerateSummary(false)}
              disabled={status !== 'idle'}
              className={`p-2.5 rounded-xl transition-all border border-transparent ${
                status !== 'idle' ? 'text-slate-300 cursor-not-allowed' : 'text-slate-500 hover:text-aurora-purple hover:bg-white hover:border-aurora-purple/20 hover:shadow-sm'
              }`}
              title="ç”Ÿæˆä»Šæ—¥æ—¥ç»“"
            >
              <ScrollText size={20} />
            </button>
            <button 
              onClick={() => setShowHistory(true)}
              className="p-2.5 text-slate-500 hover:text-aurora-green hover:bg-white hover:border-aurora-green/20 border border-transparent rounded-xl transition-all hover:shadow-sm"
              title="å†å²æ—¥è®°"
            >
              <HistoryIcon size={20} />
            </button>
          </div>
        </div>
      </header>

      <main className="flex-1 overflow-y-auto overflow-x-hidden w-full scroll-smooth">
        <div className="max-w-2xl mx-auto w-full px-4 py-6 pb-32 space-y-2">
          {messages.map(msg => (
            <ChatMessage 
              key={msg.id} 
              message={msg} 
              onDelete={handleDeleteMessage}
            />
          ))}
          
          {status === 'thinking' && (
            <div className="flex items-center gap-2 text-slate-400 text-xs ml-5 mb-4 animate-pulse font-mono bg-white/40 inline-block px-3 py-1 rounded-full border border-white/50">
              <Sparkles size={12} className="text-aurora-purple" />
              <span>Thinking...</span>
            </div>
          )}
          
          {status === 'generating_summary' && (
            <div className="flex items-center gap-2 text-aurora-green text-xs ml-5 mb-4 animate-pulse font-mono bg-white/40 inline-block px-3 py-1 rounded-full border border-white/50">
              <ScrollText size={12} />
              <span>Generating Summary...</span>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>
      </main>

      <InputArea onSendMessage={handleSendMessage} isLoading={status !== 'idle'} />

      {showSummary && summaryData && (
        <DailySummary 
          data={summaryData} 
          onClose={() => setShowSummary(false)} 
        />
      )}

      {showHistory && (
        <HistoryView 
          history={history}
          onSelect={handleHistorySelect}
          onDelete={handleDeleteHistory}
          onClose={() => setShowHistory(false)}
        />
      )}
    </div>
  );
}
